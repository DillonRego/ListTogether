{"ast":null,"code":"import e from \"axios\";\nimport t from \"js-cookie\";\nconst r = {\n  user: {},\n  tokens: {},\n  mode: \"live\"\n};\nfunction n(e) {\n  try {\n    const t = e.split(\".\")[1].replace(\"-\", \"+\").replace(\"_\", \"/\");\n    return JSON.parse(atob(t));\n  } catch (e) {\n    console.error(\"Problem decoding JWT payload\", e);\n  }\n}\nfunction o(e) {\n  try {\n    if (!e) return !1;\n    const t = n(e);\n    return new Date(1e3 * t.exp) > new Date();\n  } catch (e) {\n    return !1;\n  }\n}\nfunction i(e) {\n  var t, r;\n  if (e) {\n    if (\"string\" == typeof e) throw new Error(e);\n    if (null != e && null != (t = e.response) && null != (r = t.data) && r.message) throw new Error(e.response.data.message);\n    throw e;\n  }\n}\nconst s = r.user;\nfunction a(e) {\n  return e.replace(/([^:]\\/)\\/+/g, \"$1\");\n}\nconst c = function (t, n, o) {\n    try {\n      const i = a(`${r.baseUrl}${t}`);\n      return Promise.resolve(e.put(i, n, o));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  u = function (t, n, o) {\n    try {\n      const i = a(`${r.baseUrl}${t}`);\n      return Promise.resolve(e.post(i, n, o));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  d = function (t, n) {\n    try {\n      const o = a(`${r.baseUrl}${t}`);\n      return Promise.resolve(e.get(o, n));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\nfunction h(e, n, o) {\n  const i = `${o}.${r.tenantId}`;\n  n = n || {\n    secure: \"live\" === r.mode,\n    sameSite: \"Lax\"\n  }, \"refresh\" === o && (n.sameSite = \"Strict\"), t.set(i, e, n);\n}\nfunction l(e) {\n  let r, n;\n  try {\n    const e = window.location.pathname,\n      t = window.location.hostname,\n      o = t.split(\".\").slice(-2).join(\".\");\n    r = [void 0, e, \"/\"], n = [void 0, t, `.${t}`, o, `.${o}`];\n  } catch (e) {\n    r = [void 0, \"/\"], n = [void 0];\n  }\n  r.map(r => {\n    n.map(n => {\n      const o = {};\n      n && (o.domain = n), r && (o.path = r), t.remove(e, o);\n    });\n  });\n}\nfunction f() {\n  l(r.tokens.accessTokenName), l(r.tokens.idTokenName), l(r.tokens.refreshTokenName), r.tokens.accessToken = void 0, r.tokens.idToken = void 0, r.tokens.refreshToken = void 0, function () {\n    for (const e in r.user) \"function\" != typeof r.user[e] && delete r.user[e];\n  }();\n}\nfunction m(e) {\n  h(e.access.value, e.access.cookieOptions, \"access\"), h(e.id.value, e.id.cookieOptions, \"id\"), e.refresh && e.refresh.value && h(e.refresh.value, e.refresh.cookieOptions, \"refresh\"), k();\n}\nfunction w(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n  return r && r.then ? r.then(void 0, t) : r;\n}\nconst p = function (_ref) {\n    let {} = _ref;\n    return Promise.resolve();\n  },\n  v = function () {\n    try {\n      const e = w(function () {\n        return Promise.resolve(function () {\n          try {\n            const e = t.get(r.tokens.refreshTokenName);\n            return Promise.resolve(w(function () {\n              return Promise.resolve(d(\"/auth/refresh\", {\n                headers: {\n                  authorization: `Bearer ${e}`\n                }\n              })).then(function (_ref2) {\n                let {\n                  data: e,\n                  status: t\n                } = _ref2;\n                if (200 !== t) throw new Error(e.message || \"Problem with request\");\n                if (e.tokens) return m(e.tokens), e;\n                throw new Error(\"Problem setting cookies\");\n              });\n            }, function (e) {\n              i(e);\n            }));\n          } catch (e) {\n            return Promise.reject(e);\n          }\n        }()).then(function () {});\n      }, function (e) {\n        console.warn(`Refresh failed: ${e.message}`);\n      });\n      return Promise.resolve(e && e.then ? e.then(function () {}) : void 0);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\nfunction k() {\n  [\"access\", \"id\", \"refresh\"].map(e => {\n    try {\n      const o = t.get(r.tokens[`${e}TokenName`]);\n      r.tokens[`${e}Token`] = o, \"id\" === e && o && function () {\n        if (!r.tokens.idToken) return console.warn(\"Cannot define user: missing ID token\");\n        r.user = r.user || {};\n        const e = n(r.tokens.idToken),\n          t = [\"email\", \"phoneNumber\", \"username\", \"name\", \"image\", \"data\", \"confirmedAt\", \"createdAt\", \"updatedAt\", \"mode\", \"userId\", \"userUuid\", \"tenantId\", \"isConfirmed\"];\n        for (const n of t) {\n          if (\"update\" === n) return;\n          r.user[n] = e[n];\n        }\n      }();\n    } catch (t) {\n      console.warn(`Problem setting ${e} token.`);\n    }\n  });\n}\nfunction P() {\n  return o(r.tokens.accessToken);\n}\nr.tokens = r.tokens || {}, r.tokens.refresh = v;\nconst g = r.tokens,\n  y = function () {\n    try {\n      return Promise.resolve(I()).then(function (e) {\n        return {\n          isLoggedIn: e\n        };\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  I = function () {\n    return Promise.resolve(function (e, t) {\n      try {\n        var n = !!P() || !!o(r.tokens.refreshToken) && Promise.resolve(v()).then(function () {\n          return P();\n        });\n      } catch (e) {\n        return !1;\n      }\n      return n && n.then ? n.then(void 0, function () {\n        return !1;\n      }) : n;\n    }());\n  };\nfunction b(e) {\n  if (\"object\" == typeof window && \"object\" == typeof window.location && window.location.href && !(window.location.href.indexOf(`${e}=`) < 0)) return decodeURIComponent(window.location.href.split(`${e}=`)[1].split(\"&\")[0]);\n}\nconst T = _ref3 => {\n  let {\n    redirect: e,\n    data: t\n  } = _ref3;\n  !1 !== e && $(e || b(\"redirect\") || t.redirectTo || \"/\");\n};\nfunction $(e) {\n  if (!e || \"object\" != typeof document || \"object\" != typeof window) return;\n  try {\n    document && window;\n  } catch (e) {\n    return;\n  }\n  const t = document.createElement(\"a\");\n  t.href = e, t.pathname !== window.location.pathname && window.location.assign(`${t.pathname}${t.hash}${t.search}`);\n}\nfunction E(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n  return r && r.then ? r.then(void 0, t) : r;\n}\nconst j = function (_ref4) {\n    let {\n      password: e,\n      existingPassword: t\n    } = _ref4;\n    try {\n      return Promise.resolve(E(function () {\n        if (!r.tokens.accessToken) throw new Error('updatePassword({ method: \"jwt\" }) was called without a JWT access token.');\n        return Promise.resolve(c(\"/auth/basic\", {\n          tenantId: r.tenantId,\n          password: e,\n          existingPassword: t\n        }, {\n          headers: {\n            Authorization: `Bearer ${r.tokens.accessToken}`\n          }\n        })).then(function (_ref5) {\n          let {\n            data: e\n          } = _ref5;\n          return e;\n        });\n      }, function (e) {\n        i(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  U = function (_ref6) {\n    let {\n      uuid: e,\n      token: t,\n      password: n,\n      redirect: o\n    } = _ref6;\n    try {\n      return Promise.resolve(E(function () {\n        if (t = t || b(\"token\"), e = e || b(\"uuid\"), !t || !e) throw new Error(\"Missing token or uuid\");\n        return Promise.resolve(c(\"/auth/reset\", {\n          tenantId: r.tenantId,\n          uuid: e,\n          token: t,\n          password: n\n        })).then(function (_ref7) {\n          let {\n            data: e\n          } = _ref7;\n          if (e.tokens) return m(e.tokens), T({\n            redirect: o,\n            data: e\n          }), e;\n          throw new Error(\"There was a problem resetting your password. Please try again.\");\n        });\n      }, function (e) {\n        i(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  N = function (_ref8) {\n    let {\n      method: e,\n      password: t,\n      existingPassword: n,\n      uuid: o,\n      token: i,\n      redirect: s\n    } = _ref8;\n    try {\n      switch (e) {\n        case \"link\":\n          return U({\n            uuid: o,\n            token: i,\n            password: t,\n            redirect: s\n          });\n        case \"jwt\":\n          return j({\n            password: t,\n            existingPassword: n\n          });\n        default:\n          if (i = i || b(\"token\"), (o = o || b(\"uuid\")) && i) return U({\n            uuid: o,\n            token: i,\n            password: t,\n            redirect: s\n          });\n          if (r.tokens.accessToken) return j({\n            password: t,\n            existingPassword: n\n          });\n          throw new Error(\"updatePassword() was called without link credentials (token & uuid) or a JWT access token.\");\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  C = N;\nfunction O(_ref9) {\n  let {\n    provider: e,\n    redirect: t\n  } = _ref9;\n  if (!e) throw new Error(\"Missing provider\");\n  const n = function (_ref10) {\n    let {\n      provider: e,\n      redirect: t\n    } = _ref10;\n    if (!e) throw new Error(\"Missing provider\");\n    if (!r.tenantId) throw new Error(\"Missing tenantId\");\n    let n = `${r.baseUrl}auth/${e}/login?tenant_id=${r.tenantId}&origin=${window.location.origin}`,\n      o = t || b(\"redirect\");\n    return !1 === t && (o = \"object\" == typeof document && document.location.pathname), o && (n += `&redirect=${encodeURIComponent(o)}`), n;\n  }({\n    provider: e,\n    redirect: t\n  });\n  window.location.assign(n);\n}\nfunction x(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n  return r && r.then ? r.then(void 0, t) : r;\n}\nconst z = function (_ref11) {\n  let {\n    email: e,\n    name: t,\n    username: n,\n    userData: o,\n    options: s\n  } = _ref11;\n  try {\n    return Promise.resolve(x(function () {\n      return Promise.resolve(u(\"/auth/link\", {\n        email: e,\n        name: t,\n        username: n,\n        data: o,\n        options: s,\n        tenantId: r.tenantId\n      })).then(function (_ref12) {\n        let {\n          data: e\n        } = _ref12;\n        return e;\n      });\n    }, function (e) {\n      i(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nfunction L(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n  return r && r.then ? r.then(void 0, t) : r;\n}\nfunction S(_ref13) {\n  let {\n    channel: e,\n    phoneNumber: t,\n    email: r\n  } = _ref13;\n  if (\"sms\" !== e && \"email\" !== e) throw new Error(\"Invalid channel\");\n  if (\"sms\" === e && !t) throw new Error('SMS verification code requires \"phoneNumber\"');\n  if (\"email\" === e && !r) throw new Error('Email verification code requires \"email\"');\n}\nconst M = function (_ref14) {\n  let {\n    channel: e = \"sms\",\n    phoneNumber: t,\n    email: n,\n    name: o,\n    username: s,\n    data: a\n  } = _ref14;\n  try {\n    return Promise.resolve(L(function () {\n      return S({\n        channel: e,\n        phoneNumber: t,\n        email: n\n      }), Promise.resolve(u(\"/auth/code\", {\n        channel: e,\n        email: n,\n        phoneNumber: t,\n        name: o,\n        username: s,\n        data: a,\n        tenantId: r.tenantId\n      })).then(function (_ref15) {\n        let {\n          data: e\n        } = _ref15;\n        return e;\n      });\n    }, function (e) {\n      i(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nfunction B(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n  return r && r.then ? r.then(void 0, t) : r;\n}\nfunction D(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n  return r && r.then ? r.then(void 0, t) : r;\n}\nconst R = /((^127\\.)|(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.))\\d{1,3}\\.\\d{1,3}/g,\n  A = function () {\n    try {\n      const e = function (e, t) {\n        try {\n          var n = Promise.resolve(d(`/tenants/${r.tenantId}/mode`)).then(function (_ref16) {\n            let {\n              data: e\n            } = _ref16;\n            J.value = e.mode || \"test\", J.reason = q(J.value), r.mode = J.value;\n          });\n        } catch (e) {\n          return t();\n        }\n        return n && n.then ? n.then(void 0, t) : n;\n      }(0, function () {\n        J.value = \"test\", r.mode = J.value;\n      });\n      return Promise.resolve(e && e.then ? e.then(function () {}) : void 0);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  J = {\n    value: \"live\",\n    reason: void 0,\n    setMode: A\n  };\nfunction W() {\n  const e = function (e) {\n    try {\n      const e = window.location.hostname;\n      return !(!e.match(/localhost/g) && !e.match(R));\n    } catch (e) {\n      return !0;\n    }\n  }() || !function () {\n    try {\n      return \"https:\" === window.location.protocol;\n    } catch (e) {\n      return !1;\n    }\n  }() ? \"test\" : \"live\";\n  J.value = e, J.reason = q(e), r.mode = e;\n}\nfunction q(e) {\n  try {\n    return \"live\" === e ? \"domain\" : \"http:\" === window.location.protocol ? \"http\" : \"https:\" !== window.location.protocol ? \"protocol\" : \"domain\";\n  } catch (e) {}\n}\nW(), r.user.update = function (e) {\n  try {\n    return !e || Object.keys(e).length < 1 ? Promise.resolve(console.warn(\"Missing user properties to update\")) : Promise.resolve(c(\"/self\", e, {\n      headers: {\n        authorization: `Bearer ${r.tokens.accessToken}`\n      }\n    })).then(function () {\n      return Promise.resolve(v()).then(function () {\n        return r.user;\n      });\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}, r.user.hasRole = function (e) {\n  let {\n    tenantId: t\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  try {\n    if (!r.tokens.accessToken || !r.tenantId) return !1;\n    const {\n      authorization: o\n    } = n(r.tokens.accessToken);\n    return !!o && !(!o[t = t || r.tenantId] || !o[t].roles) && o[t].roles.indexOf(e) > -1;\n  } catch (e) {\n    return !1;\n  }\n}, r.user.updatePassword = N, r.user.getTotp = function () {\n  try {\n    return Promise.resolve(B(function () {\n      if (!r.tokens.accessToken) throw new Error(\"getTotp() was called without a JWT access token.\");\n      return Promise.resolve(d(\"/auth/totp\", {\n        headers: {\n          Authorization: `Bearer ${r.tokens.accessToken}`\n        }\n      })).then(function (_ref17) {\n        let {\n          data: e\n        } = _ref17;\n        return e;\n      });\n    }, function (e) {\n      i(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nlet F = [],\n  _ = !1;\nvar V = {\n  addInitCallback: function (e) {\n    e && \"function\" == typeof e && F.push(e);\n  },\n  init: function (t) {\n    let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!t) return console.warn(\"Userfront initialized without tenantId\");\n    if (r.tenantId = t, r.baseUrl = n.baseUrl || \"https://api.userfront.com/v0/\", r.baseUrl.endsWith(\"/\") || (r.baseUrl += \"/\"), n.domain) {\n      r.domain = n.domain;\n      const t = `https://${r.domain}`;\n      e.defaults.headers.common[\"x-application-id\"] = t, e.defaults.headers.common[\"x-origin\"] = t;\n    }\n    r.tokens = r.tokens || {}, r.tokens.accessTokenName = `access.${r.tenantId}`, r.tokens.idTokenName = `id.${r.tenantId}`, r.tokens.refreshTokenName = `refresh.${r.tenantId}`, k(), W();\n    try {\n      F.length > 0 && F.forEach(e => {\n        e && \"function\" == typeof e && e({\n          tenantId: t\n        });\n      }), F = [];\n    } catch (e) {}\n  },\n  registerUrlChangedEventListener: function () {\n    if (!_) {\n      _ = !0;\n      try {\n        history.pushState = (e = history.pushState, function () {\n          var t = e.apply(this, arguments);\n          return window.dispatchEvent(new Event(\"pushstate\")), window.dispatchEvent(new Event(\"urlchanged\")), t;\n        }), history.replaceState = (e => function () {\n          var t = e.apply(this, arguments);\n          return window.dispatchEvent(new Event(\"replacestate\")), window.dispatchEvent(new Event(\"urlchanged\")), t;\n        })(history.replaceState), window.addEventListener(\"popstate\", () => {\n          window.dispatchEvent(new Event(\"urlchanged\"));\n        });\n      } catch (e) {}\n      var e;\n    }\n  },\n  logout: function () {\n    let {\n      method: e,\n      redirect: t\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      if (\"saml\" === e) return function () {\n        try {\n          if (!r.tokens.accessToken) throw new Error(\"Please log in to authorize your logout request.\");\n          const e = D(function () {\n            return Promise.resolve(d(\"/auth/saml/idp/token\", {\n              headers: {\n                authorization: `Bearer ${r.tokens.accessToken}`\n              }\n            })).then(function (_ref18) {\n              let {\n                data: e\n              } = _ref18;\n              window.location.assign(`${r.baseUrl}auth/saml/idp/logout?tenant_id=${r.tenantId}&token=${e.token}&uuid=${r.user.userUuid}`);\n            });\n          }, function (e) {\n            i(e);\n          });\n          return Promise.resolve(e && e.then ? e.then(function () {}) : void 0);\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }();\n      if (!r.tokens.accessToken) return Promise.resolve(f());\n      const n = D(function () {\n        return Promise.resolve(d(\"/auth/logout\", {\n          headers: {\n            authorization: `Bearer ${r.tokens.accessToken}`\n          }\n        })).then(function (_ref19) {\n          let {\n            data: e\n          } = _ref19;\n          f(), T({\n            redirect: t,\n            data: e\n          });\n        });\n      }, function () {\n        f();\n      });\n      return Promise.resolve(n && n.then ? n.then(function () {}) : void 0);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  mode: J,\n  setMode: A,\n  refresh: (e, t, r) => {\n    try {\n      console.warn(\"Userfront.refresh() is deprecated and will be removed. Please use Userfront.tokens.refresh() instead.\");\n    } catch (e) {}\n    return v();\n  },\n  login: function () {\n    let {\n      method: e,\n      userId: t,\n      userUuid: n,\n      email: o,\n      username: s,\n      emailOrUsername: a,\n      phoneNumber: h,\n      password: l,\n      token: f,\n      uuid: w,\n      totpCode: v,\n      backupCode: k,\n      channel: P,\n      verificationCode: g,\n      redirect: y\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      if (!e) throw new Error('Userfront.login called without \"method\" property.');\n      switch (e) {\n        case \"apple\":\n        case \"azure\":\n        case \"facebook\":\n        case \"github\":\n        case \"google\":\n        case \"linkedin\":\n          return Promise.resolve(O({\n            provider: e,\n            redirect: y\n          }));\n        case \"password\":\n          return Promise.resolve(function (_ref20) {\n            let {\n              email: e,\n              username: t,\n              emailOrUsername: n,\n              password: o,\n              redirect: s\n            } = _ref20;\n            try {\n              return Promise.resolve(E(function () {\n                return Promise.resolve(u(\"/auth/basic\", {\n                  tenantId: r.tenantId,\n                  emailOrUsername: e || t || n,\n                  password: o\n                })).then(function (_ref21) {\n                  let {\n                    data: e\n                  } = _ref21;\n                  let t;\n                  function r(r) {\n                    if (t) return r;\n                    if (e.hasOwnProperty(\"firstFactorCode\")) return e;\n                    throw new Error(\"Please try again.\");\n                  }\n                  const n = function () {\n                    if (e.hasOwnProperty(\"tokens\")) return m(e.tokens), Promise.resolve(p(e)).then(function () {\n                      return T({\n                        redirect: s,\n                        data: e\n                      }), t = 1, e;\n                    });\n                  }();\n                  return n && n.then ? n.then(r) : r(n);\n                });\n              }, function (e) {\n                i(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            email: o,\n            username: s,\n            emailOrUsername: a,\n            password: l,\n            redirect: y\n          }));\n        case \"passwordless\":\n          return Promise.resolve(z({\n            email: o\n          }));\n        case \"link\":\n          return Promise.resolve(function () {\n            let {\n              token: e,\n              uuid: t,\n              redirect: n\n            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            try {\n              return Promise.resolve(x(function () {\n                if (e = e || b(\"token\"), t = t || b(\"uuid\"), e && t) return Promise.resolve(c(\"/auth/link\", {\n                  token: e,\n                  uuid: t,\n                  tenantId: r.tenantId\n                })).then(function (_ref22) {\n                  let {\n                    data: e\n                  } = _ref22;\n                  let t;\n                  function r(r) {\n                    if (t) return r;\n                    if (e.hasOwnProperty(\"firstFactorCode\")) return e;\n                    throw new Error(\"Problem logging in.\");\n                  }\n                  const o = function () {\n                    if (e.hasOwnProperty(\"tokens\")) return m(e.tokens), Promise.resolve(p(e)).then(function () {\n                      return T({\n                        redirect: n,\n                        data: e\n                      }), t = 1, e;\n                    });\n                  }();\n                  return o && o.then ? o.then(r) : r(o);\n                });\n              }, function (e) {\n                i(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            token: f,\n            uuid: w,\n            redirect: y\n          }));\n        case \"totp\":\n          return Promise.resolve(function () {\n            let {\n              totpCode: e,\n              backupCode: t,\n              userId: n,\n              userUuid: o,\n              emailOrUsername: s,\n              email: a,\n              username: c,\n              phoneNumber: d,\n              redirect: h\n            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            try {\n              return Promise.resolve(B(function () {\n                if (e || t) return Promise.resolve(u(\"/auth/totp\", {\n                  totpCode: e,\n                  backupCode: t,\n                  userId: n,\n                  userUuid: o,\n                  emailOrUsername: s,\n                  email: a,\n                  username: c,\n                  phoneNumber: d,\n                  tenantId: r.tenantId\n                })).then(function (_ref23) {\n                  let {\n                    data: e\n                  } = _ref23;\n                  let t;\n                  function r(r) {\n                    if (t) return r;\n                    if (e.hasOwnProperty(\"firstFactorCode\")) return e;\n                    throw new Error(\"Problem logging in.\");\n                  }\n                  const n = function () {\n                    if (e.hasOwnProperty(\"tokens\")) return m(e.tokens), Promise.resolve(p(e)).then(function () {\n                      return T({\n                        redirect: h,\n                        data: e\n                      }), t = 1, e;\n                    });\n                  }();\n                  return n && n.then ? n.then(r) : r(n);\n                });\n              }, function (e) {\n                i(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            totpCode: v,\n            backupCode: k,\n            userId: t,\n            userUuid: n,\n            emailOrUsername: a,\n            email: o,\n            username: s,\n            phoneNumber: h,\n            redirect: y\n          }));\n        case \"verificationCode\":\n          return Promise.resolve(function () {\n            let {\n              channel: e,\n              verificationCode: t,\n              email: n,\n              phoneNumber: o,\n              redirect: s\n            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            try {\n              return Promise.resolve(L(function () {\n                return S({\n                  channel: e,\n                  phoneNumber: o,\n                  email: n\n                }), Promise.resolve(c(\"/auth/code\", {\n                  channel: e,\n                  verificationCode: t,\n                  email: n,\n                  phoneNumber: o,\n                  tenantId: r.tenantId\n                })).then(function (_ref24) {\n                  let {\n                    data: e\n                  } = _ref24;\n                  let t;\n                  function r(r) {\n                    if (t) return r;\n                    if (e.hasOwnProperty(\"firstFactorCode\")) return e;\n                    throw new Error(\"Problem logging in.\");\n                  }\n                  const n = function () {\n                    if (e.hasOwnProperty(\"tokens\")) return m(e.tokens), Promise.resolve(p(e)).then(function () {\n                      return T({\n                        redirect: s,\n                        data: e\n                      }), t = 1, e;\n                    });\n                  }();\n                  return n && n.then ? n.then(r) : r(n);\n                });\n              }, function (e) {\n                i(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            channel: P,\n            email: o,\n            phoneNumber: h,\n            verificationCode: g,\n            redirect: y\n          }));\n        case \"saml\":\n          return Promise.resolve(function () {\n            try {\n              return Promise.resolve(function (e, t) {\n                try {\n                  var n = r.tokens.accessToken ? Promise.resolve(d(\"/auth/saml/idp/token\", {\n                    headers: {\n                      authorization: `Bearer ${r.tokens.accessToken}`\n                    }\n                  })).then(function (_ref25) {\n                    let {\n                      data: e\n                    } = _ref25;\n                    window.location.assign(`${r.baseUrl}auth/saml/idp/login?tenant_id=${r.tenantId}&token=${e.token}&uuid=${r.user.userUuid}`);\n                  }) : console.warn(\"Cannot complete SAML login without access token\");\n                } catch (e) {\n                  return t(e);\n                }\n                return n && n.then ? n.then(void 0, t) : n;\n              }(0, function (e) {\n                i(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }());\n        default:\n          throw new Error('Userfront.login called with invalid \"method\" property.');\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  resetPassword: C,\n  updatePassword: N,\n  sendLoginLink: function (e) {\n    try {\n      return Promise.resolve(x(function () {\n        return Promise.resolve(u(\"/auth/link\", {\n          email: e,\n          tenantId: r.tenantId\n        })).then(function (_ref26) {\n          let {\n            data: e\n          } = _ref26;\n          return e;\n        });\n      }, function (e) {\n        i(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  sendResetLink: function (e) {\n    try {\n      return Promise.resolve(E(function () {\n        return Promise.resolve(u(\"/auth/reset/link\", {\n          email: e,\n          tenantId: r.tenantId\n        })).then(function (_ref27) {\n          let {\n            data: e\n          } = _ref27;\n          return e;\n        });\n      }, function (e) {\n        i(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  sendVerificationCode: M,\n  signup: function () {\n    let {\n      method: e,\n      email: t,\n      username: n,\n      phoneNumber: o,\n      name: s,\n      data: a,\n      password: c,\n      channel: d,\n      redirect: h\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      if (!e) throw new Error('Userfront.signup called without \"method\" property.');\n      switch (e) {\n        case \"apple\":\n        case \"azure\":\n        case \"facebook\":\n        case \"github\":\n        case \"google\":\n        case \"linkedin\":\n          return Promise.resolve(O({\n            provider: e,\n            redirect: h\n          }));\n        case \"password\":\n          return Promise.resolve(function () {\n            let {\n              username: e,\n              name: t,\n              email: n,\n              password: o,\n              userData: s,\n              redirect: a\n            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            try {\n              return Promise.resolve(E(function () {\n                return Promise.resolve(u(\"/auth/create\", {\n                  tenantId: r.tenantId,\n                  username: e,\n                  name: t,\n                  email: n,\n                  password: o,\n                  data: s\n                })).then(function (_ref28) {\n                  let {\n                    data: e\n                  } = _ref28;\n                  if (e.tokens) return m(e.tokens), Promise.resolve(p(e)).then(function () {\n                    return T({\n                      redirect: a,\n                      data: e\n                    }), e;\n                  });\n                  throw new Error(\"Please try again.\");\n                });\n              }, function (e) {\n                i(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            username: n,\n            name: s,\n            email: t,\n            password: c,\n            userData: a,\n            redirect: h\n          }));\n        case \"passwordless\":\n          return Promise.resolve(z({\n            email: t,\n            name: s,\n            username: n,\n            userData: a\n          }));\n        case \"verificationCode\":\n          return Promise.resolve(M({\n            channel: d,\n            email: t,\n            phoneNumber: o,\n            name: s,\n            username: n,\n            data: a\n          }));\n        default:\n          throw new Error('Userfront.signup called with invalid \"method\" property.');\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  store: r,\n  tokens: g,\n  accessToken: function () {\n    return r.tokens.accessToken = t.get(r.tokens.accessTokenName), r.tokens.accessToken;\n  },\n  idToken: function () {\n    return r.tokens.idToken = t.get(r.tokens.idTokenName), r.tokens.idToken;\n  },\n  getSession: y,\n  redirectIfLoggedIn: function () {\n    let {\n      redirect: e\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      return Promise.resolve(y()).then(function (_ref29) {\n        let {\n          isLoggedIn: t\n        } = _ref29;\n        if (!t) return f();\n        if (e) return $(e);\n        if (b(\"redirect\")) return $(b(\"redirect\"));\n        const n = function (e, t) {\n          try {\n            var n = Promise.resolve(d(\"/self\", {\n              headers: {\n                authorization: `Bearer ${r.tokens.accessToken}`\n              }\n            })).then(function (_ref30) {\n              let {\n                data: e\n              } = _ref30;\n              e.tenant && e.tenant.loginRedirectPath && $(e.tenant.loginRedirectPath);\n            });\n          } catch (e) {\n            return t();\n          }\n          return n && n.then ? n.then(void 0, t) : n;\n        }(0, function () {\n          f();\n        });\n        return n && n.then ? n.then(function () {}) : void 0;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  redirectIfLoggedOut: function () {\n    let {\n      redirect: e\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      return Promise.resolve(y()).then(function (_ref31) {\n        let {\n          isLoggedIn: t\n        } = _ref31;\n        if (!t) return f(), e ? $(e) : b(\"redirect\") ? $(b(\"redirect\")) : void 0;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  user: s\n};\nexport { V as default };","map":{"version":3,"mappings":"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","names":["store","user","tokens","mode","getJwtPayload","token","encodedPayload","split","replace","JSON","parse","atob","error","console","isJwtLocallyValid","payload","Date","exp","throwFormattedError","Error","response","_error$response","data","_error$response$data","message","reduceSlashes","str","put","path","options","url","baseUrl","axios","post","e","get","setCookie","value","type","cookieName","tenantId","secure","sameSite","Cookies","set","removeCookie","name","paths","domains","window","location","pathname","hostname","primaryDomain","slice","join","undefined","err","map","domain","remove","removeAllCookies","accessTokenName","idTokenName","refreshTokenName","accessToken","idToken","refreshToken","attr","unsetUser","setCookiesAndTokens","access","cookieOptions","id","refresh","setTokensFromCookies","body","recover","result","then","exchange","basicRefresh","headers","authorization","status","warn","tokenName","idTokenPayload","propsToDefine","prop","setUser","isAccessTokenLocallyValid","getSession","getIsLoggedIn","isLoggedIn","_catch","getQueryAttr","attrName","href","indexOf","decodeURIComponent","handleRedirect","redirect","redirectToPath","redirectTo","pathOrUrl","document","el","createElement","assign","hash","search","updatePasswordWithJwt","existingPassword","password","Authorization","updatePasswordWithLink","uuid","updatePassword","method","resetPassword","signonWithSso","provider","origin","encodeURIComponent","getProviderLink","sendPasswordlessLink","email","username","userData","enforceChannel","channel","phoneNumber","sendVerificationCode","Promise","res","privateIPRegex","setMode","reason","getReason","setModeSync","modeValue","isTestHostname","hn","match","protocol","isHttps","update","Object","keys","length","hasRole","roleName","roles","getTotp","initCallbacks","isRegistered","addInitCallback","cb","push","init","opts","endsWith","defaults","common","forEach","registerUrlChangedEventListener","history","pushState","f","ret","apply","this","arguments","dispatchEvent","Event","replaceState","addEventListener","logout","_temp2","userUuid","completeSamlLogout","a","b","c","login","userId","emailOrUsername","totpCode","backupCode","verificationCode","hasOwnProperty","_exit","loginWithPassword","loginWithLink","loginWithTotp","loginWithVerificationCode","completeSamlLogin","sendLoginLink","sendResetLink","signup","signupWithPassword","redirectIfLoggedIn","tenant","loginRedirectPath","redirectIfLoggedOut"],"sources":["/Users/anthonyteciorowski/Desktop/Code/CSC349/ListTogether/app/node_modules/@userfront/core/src/store.js","/Users/anthonyteciorowski/Desktop/Code/CSC349/ListTogether/app/node_modules/@userfront/core/src/utils.js","/Users/anthonyteciorowski/Desktop/Code/CSC349/ListTogether/app/node_modules/@userfront/core/src/user.js","/Users/anthonyteciorowski/Desktop/Code/CSC349/ListTogether/app/node_modules/@userfront/core/src/api.js","/Users/anthonyteciorowski/Desktop/Code/CSC349/ListTogether/app/node_modules/@userfront/core/src/cookies.js","/Users/anthonyteciorowski/Desktop/Code/CSC349/ListTogether/app/node_modules/@userfront/core/src/tokens.js","/Users/anthonyteciorowski/Desktop/Code/CSC349/ListTogether/app/node_modules/@userfront/core/src/refresh.js","/Users/anthonyteciorowski/Desktop/Code/CSC349/ListTogether/app/node_modules/@userfront/core/src/session.js","/Users/anthonyteciorowski/Desktop/Code/CSC349/ListTogether/app/node_modules/@userfront/core/src/url.js","/Users/anthonyteciorowski/Desktop/Code/CSC349/ListTogether/app/node_modules/@userfront/core/src/password.js","/Users/anthonyteciorowski/Desktop/Code/CSC349/ListTogether/app/node_modules/@userfront/core/src/sso.js","/Users/anthonyteciorowski/Desktop/Code/CSC349/ListTogether/app/node_modules/@userfront/core/src/link.js","/Users/anthonyteciorowski/Desktop/Code/CSC349/ListTogether/app/node_modules/@userfront/core/src/verificationCode.js","/Users/anthonyteciorowski/Desktop/Code/CSC349/ListTogether/app/node_modules/@userfront/core/src/totp.js","/Users/anthonyteciorowski/Desktop/Code/CSC349/ListTogether/app/node_modules/@userfront/core/src/logout.js","/Users/anthonyteciorowski/Desktop/Code/CSC349/ListTogether/app/node_modules/@userfront/core/src/constants.js","/Users/anthonyteciorowski/Desktop/Code/CSC349/ListTogether/app/node_modules/@userfront/core/src/mode.js","/Users/anthonyteciorowski/Desktop/Code/CSC349/ListTogether/app/node_modules/@userfront/core/src/user.methods.js","/Users/anthonyteciorowski/Desktop/Code/CSC349/ListTogether/app/node_modules/@userfront/core/src/index.js","/Users/anthonyteciorowski/Desktop/Code/CSC349/ListTogether/app/node_modules/@userfront/core/src/login.js","/Users/anthonyteciorowski/Desktop/Code/CSC349/ListTogether/app/node_modules/@userfront/core/src/saml.js","/Users/anthonyteciorowski/Desktop/Code/CSC349/ListTogether/app/node_modules/@userfront/core/src/signup.js"],"sourcesContent":["export const store = {\n  user: {},\n  tokens: {},\n  mode: \"live\",\n};\n","/**\n * This file is for zero-dependency utilities that can\n * be imported by any other file. Don't add any imports\n * to this file other than constants\n */\n\n/**\n * Get the unverified base64 decoded payload of a JWT\n *\n * @param {String} token - JSON Web Token\n * @returns {Object}\n */\nexport function getJwtPayload(token) {\n  try {\n    const encodedPayload = token\n      .split(\".\")[1]\n      .replace(\"-\", \"+\")\n      .replace(\"_\", \"/\");\n    return JSON.parse(atob(encodedPayload));\n  } catch (error) {\n    console.error(\"Problem decoding JWT payload\", error);\n  }\n}\n\n/**\n * Client-side check:\n * Determine whether the given JWT is present and unexpired\n *\n * @param {String} token JSON Web Token\n * @returns {Boolean}\n */\nexport function isJwtLocallyValid(token) {\n  try {\n    // Must be present\n    if (!token) {\n      return false;\n    }\n\n    // Must not be expired\n    const payload = getJwtPayload(token);\n    return new Date(payload.exp * 1000) > new Date();\n  } catch (error) {\n    return false;\n  }\n}\n\nexport function throwFormattedError(error) {\n  if (!error) return;\n  if (typeof error === \"string\") throw new Error(error);\n  if (error?.response?.data?.message) {\n    throw new Error(error.response.data.message);\n  }\n  throw error;\n}\n","import { store } from \"./store.js\";\nimport { getJwtPayload } from \"./utils.js\";\n\n/**\n * Define the store.user object based on the ID token\n */\nexport function setUser() {\n  if (!store.tokens.idToken) {\n    return console.warn(\"Cannot define user: missing ID token\");\n  }\n\n  store.user = store.user || {};\n  const idTokenPayload = getJwtPayload(store.tokens.idToken);\n\n  // Set basic user information properties from ID token\n  const propsToDefine = [\n    \"email\",\n    \"phoneNumber\",\n    \"username\",\n    \"name\",\n    \"image\",\n    \"data\",\n    \"confirmedAt\",\n    \"createdAt\",\n    \"updatedAt\",\n    \"mode\",\n    \"userId\",\n    \"userUuid\",\n    \"tenantId\",\n    \"isConfirmed\",\n  ];\n  for (const prop of propsToDefine) {\n    if (prop === \"update\") return;\n    store.user[prop] = idTokenPayload[prop];\n  }\n}\n\n/**\n * Remove all user information\n */\nexport function unsetUser() {\n  for (const attr in store.user) {\n    if (typeof store.user[attr] !== \"function\") {\n      delete store.user[attr];\n    }\n  }\n}\n\n/**\n * Export the store.user object with the update method added\n */\nexport const user = store.user;\n","import axios from \"axios\";\nimport { store } from \"./store.js\";\n\n// Replace multiple slashes // with single slash / (except in the protocol)\nfunction reduceSlashes(str) {\n  return str.replace(/([^:]\\/)\\/+/g, \"$1\");\n}\n\n/**\n * Perform a GET request\n * @param {String} path\n * @param {Object} options\n * @returns {Object} response body\n */\nexport async function get(path, options) {\n  const url = reduceSlashes(`${store.baseUrl}${path}`);\n  return axios.get(url, options);\n}\n\n/**\n * Perform a POST request\n * @param {String} path\n * @param {Object} payload\n * @param {Object} options\n * @returns {Object} response body\n */\nexport async function post(path, payload, options) {\n  const url = reduceSlashes(`${store.baseUrl}${path}`);\n  return axios.post(url, payload, options);\n}\n\n/**\n * Perform a PUT request\n * @param {String} path\n * @param {Object} payload\n * @param {Object} options\n * @returns {Object} response body\n */\nexport async function put(path, payload, options) {\n  const url = reduceSlashes(`${store.baseUrl}${path}`);\n  return axios.put(url, payload, options);\n}\n\nexport default {\n  get,\n  post,\n  put,\n};\n","import Cookies from \"js-cookie\";\nimport { store } from \"./store.js\";\nimport { setTokensFromCookies, unsetTokens } from \"./tokens.js\";\n\n/**\n * Set a cookie value based on the given options.\n * @param {String} value\n * @param {Object} options\n * @param {String} type\n */\nexport function setCookie(value, options, type) {\n  const cookieName = `${type}.${store.tenantId}`;\n  options = options || {\n    secure: store.mode === \"live\",\n    sameSite: \"Lax\",\n  };\n  if (type === \"refresh\") {\n    options.sameSite = \"Strict\";\n  }\n  Cookies.set(cookieName, value, options);\n}\n\n/**\n * Remove a cookie by name, regardless of its cookie setting(s).\n * @param {String} name\n */\nfunction removeCookie(name) {\n  // Define all possible path and domain combinations\n  let paths, domains;\n  try {\n    const path = window.location.pathname;\n    const hostname = window.location.hostname;\n    const hostnameParts = hostname.split(\".\");\n    const primaryDomain = hostnameParts.slice(-2).join(\".\");\n    paths = [undefined, path, \"/\"];\n    domains = [\n      undefined,\n      hostname,\n      `.${hostname}`,\n      primaryDomain,\n      `.${primaryDomain}`,\n    ];\n  } catch (err) {\n    paths = [undefined, \"/\"];\n    domains = [undefined];\n  }\n\n  // Iterate over paths and domains, and remove cookies if present\n  paths.map((path) => {\n    domains.map((domain) => {\n      const options = {};\n      if (domain) options.domain = domain;\n      if (path) options.path = path;\n      Cookies.remove(name, options);\n    });\n  });\n}\n\n/**\n * Remove all auth cookies (access, id, refresh).\n */\nexport function removeAllCookies() {\n  removeCookie(store.tokens.accessTokenName);\n  removeCookie(store.tokens.idTokenName);\n  removeCookie(store.tokens.refreshTokenName);\n  unsetTokens();\n}\n\n/**\n * Set the cookies from a tokens object, and add to the local store.\n * @param {Object} tokens\n */\nexport function setCookiesAndTokens(tokens) {\n  setCookie(tokens.access.value, tokens.access.cookieOptions, \"access\");\n  setCookie(tokens.id.value, tokens.id.cookieOptions, \"id\");\n  if (tokens.refresh && tokens.refresh.value) {\n    setCookie(tokens.refresh.value, tokens.refresh.cookieOptions, \"refresh\");\n  }\n  setTokensFromCookies();\n}\n","import Cookies from \"js-cookie\";\nimport { store } from \"./store.js\";\nimport { setUser, unsetUser } from \"./user.js\";\nimport { refresh } from \"./refresh.js\";\nimport { isJwtLocallyValid } from \"./utils.js\";\n\nstore.tokens = store.tokens || {};\nstore.tokens.refresh = refresh;\n\nexport function setTokenNames() {\n  store.tokens = store.tokens || {};\n  store.tokens.accessTokenName = `access.${store.tenantId}`;\n  store.tokens.idTokenName = `id.${store.tenantId}`;\n  store.tokens.refreshTokenName = `refresh.${store.tenantId}`;\n}\n\n/**\n * Set and then return the access token\n */\nexport function accessToken() {\n  store.tokens.accessToken = Cookies.get(store.tokens.accessTokenName);\n  return store.tokens.accessToken;\n}\n\n/**\n * Set and then return the ID token\n */\nexport function idToken() {\n  store.tokens.idToken = Cookies.get(store.tokens.idTokenName);\n  return store.tokens.idToken;\n}\n\n/**\n * Define the store token values from the cookie values.\n */\nexport function setTokensFromCookies() {\n  const tokenNames = [\"access\", \"id\", \"refresh\"];\n  tokenNames.map((tokenName) => {\n    try {\n      const token = Cookies.get(store.tokens[`${tokenName}TokenName`]);\n      store.tokens[`${tokenName}Token`] = token;\n\n      // Set the user object whenever the ID token is set\n      if (tokenName === \"id\" && token) {\n        setUser();\n      }\n    } catch (error) {\n      console.warn(`Problem setting ${tokenName} token.`);\n    }\n  });\n}\n\n/**\n * Set the store token values to undefined\n */\nexport function unsetTokens() {\n  store.tokens.accessToken = undefined;\n  store.tokens.idToken = undefined;\n  store.tokens.refreshToken = undefined;\n  unsetUser();\n}\n\n/**\n * Client-side check:\n * Determine whether the access token is present and unexpired\n * @returns {Boolean}\n */\nexport function isAccessTokenLocallyValid() {\n  return isJwtLocallyValid(store.tokens.accessToken);\n}\n\n/**\n * Client-side check:\n * Determine whether the refresh token is present and unexpired\n * @returns {Boolean}\n */\nexport function isRefreshTokenLocallyValid() {\n  return isJwtLocallyValid(store.tokens.refreshToken);\n}\n\n/**\n * Export the store.tokens object\n */\nexport const tokens = store.tokens;\n\n// NOTE Commenting this out 6/11/21 because the packages it relies on (jsonwebtoken & jwks-rsa)\n// both cause a lot of bloat. If we want to verify tokens, this is a nice way to do it, but\n// we need to find libraries designed for the browser instead of node.\n/**\n * Verify the provided token\n * @param {String} token\n * @returns {Promise<void>} The provided token has been verified if `verifyToken` resolves without error\n */\n// export async function verifyToken(token) {\n//   if (!token) throw new Error(\"Missing token\");\n\n//   let publicKey;\n//   try {\n//     const decodedToken = jwt.decode(token, { complete: true });\n//     if (!decodedToken.header || !decodedToken.header.kid) {\n//       throw new Error(\"Token kid not defined\");\n//     }\n\n//     const client = new JwksClient({\n//       jwksUri: `${apiUrl}tenants/${store.tenantId}/jwks/${store.mode}`,\n//       requestHeaders: { origin: window.location.origin },\n//     });\n\n//     const key = await client.getSigningKey(decodedToken.header.kid);\n//     publicKey = key.getPublicKey();\n//   } catch (error) {\n//     throw error;\n//   }\n\n//   if (!publicKey) {\n//     throw new Error(\"Public key not found\");\n//   }\n\n//   try {\n//     jwt.verify(token, publicKey);\n//   } catch (error) {\n//     throw new Error(\"Token verification failed\");\n//   }\n\n//   return Promise.resolve();\n// }\n","import Cookies from \"js-cookie\";\nimport { get } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\n// import { getIframe, postMessageAsPromise } from \"./iframe.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Refresh the access and ID tokens\n * - When in test mode, uses the basic refresh method\n * - For tenants without a custom SSL certificate, uses the basic refresh method\n * - For tenants with a custom SSL certificate and in live mode, uses the httpOnly refresh method\n * @returns {Promise}\n */\nexport async function refresh() {\n  try {\n    await basicRefresh();\n  } catch (error) {\n    console.warn(`Refresh failed: ${error.message}`);\n  }\n}\n\n/**\n * Use a regular (non-httpOnly) cookie to refresh the access and ID tokens.\n *\n * The basic refresh method is used automatically in test mode and in live\n * mode whenever an SSL certificate has not been set up.\n */\nasync function basicRefresh() {\n  const refreshToken = Cookies.get(store.tokens.refreshTokenName);\n  try {\n    const { data, status } = await get(`/auth/refresh`, {\n      headers: {\n        authorization: `Bearer ${refreshToken}`,\n      },\n    });\n    if (status !== 200) {\n      throw new Error(data.message || \"Problem with request\");\n    }\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      return data;\n    } else {\n      throw new Error(\"Problem setting cookies\");\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n// TODO re-enable httpOnly refresh method once new endpoints are stable [06/15/21]\n/**\n *\n * The httpOnly refresh method is only available for tenants with configured\n * SSL certificates while in live mode.\n */\n// async function httpOnlyRefresh() {\n//   const iframe = getIframe();\n//   if (!iframe) return;\n//   return postMessageAsPromise({\n//     type: \"refresh\",\n//     tenantId: store.tenantId,\n//   });\n// }\n\n/**\n * Use a sessionId and nonce to set the iframe refresh token\n * @param {String} sessionId\n * @param {String} nonce\n * @returns {Promise}\n */\nexport async function exchange({ sessionId, nonce }) {\n  return;\n\n  // TODO re-enable httpOnly exchange method once new endpoints are stable [06/15/21]\n  // --------------------------\n  // const iframe = getIframe();\n  // if (!iframe) return;\n  // return postMessageAsPromise({\n  //   type: \"exchange\",\n  //   tenantId: store.tenantId,\n  //   payload: {\n  //     sessionId,\n  //     nonce,\n  //   },\n  // });\n}\n","import {\n  isAccessTokenLocallyValid,\n  isRefreshTokenLocallyValid,\n} from \"./tokens.js\";\nimport { refresh } from \"./refresh.js\";\n\n/**\n * Determine whether a user is logged in by checking their\n * JWT access token and, if invalid, refreshing it and checking\n * again.\n * @returns {Promise<Boolean>}\n */\nasync function getIsLoggedIn() {\n  try {\n    // If the access token is locally valid, return true\n    if (isAccessTokenLocallyValid()) {\n      return true;\n    }\n\n    // If the refresh token is locally invalid, return false\n    if (!isRefreshTokenLocallyValid()) {\n      return false;\n    }\n\n    // Attempt to refresh the access token\n    await refresh();\n\n    // The access token should now be valid\n    return isAccessTokenLocallyValid();\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Return detailed information about the current session.\n * @returns {Promise<Object>}\n */\nexport async function getSession() {\n  const isLoggedIn = await getIsLoggedIn();\n  return { isLoggedIn };\n}\n","import { get } from \"./api.js\";\nimport { store } from \"./store.js\";\nimport { removeAllCookies } from \"./cookies.js\";\nimport { getSession } from \"./session.js\";\n\n/**\n * Get the value of a query attribute, e.g. ?attr=value\n * @param {String} attrName\n */\nexport function getQueryAttr(attrName) {\n  if (\n    typeof window !== \"object\" ||\n    typeof window.location !== \"object\" ||\n    !window.location.href ||\n    window.location.href.indexOf(`${attrName}=`) < 0\n  ) {\n    return;\n  }\n  return decodeURIComponent(\n    window.location.href.split(`${attrName}=`)[1].split(\"&\")[0]\n  );\n}\n\n/**\n * Redirect the browser based on explicit redirect input path, or the API response\n * @property {String|Boolean} redirect A path to redirect to, or false to not redirect\n * @property {Object} data The response object from the API\n * @returns\n */\nexport const handleRedirect = ({ redirect, data }) => {\n  if (redirect === false) return;\n  const path = redirect || getQueryAttr(\"redirect\") || data.redirectTo || \"/\";\n  redirectToPath(path);\n};\n\n/**\n * If the access token is valid, redirect the browser to the\n * tenant's After-login path.\n */\nexport async function redirectIfLoggedIn({ redirect } = {}) {\n  const { isLoggedIn } = await getSession();\n  if (!isLoggedIn) {\n    return removeAllCookies();\n  }\n\n  // Redirect to a provided path (check options first, then url querystring)\n  if (redirect) {\n    return redirectToPath(redirect);\n  } else if (getQueryAttr(\"redirect\")) {\n    return redirectToPath(getQueryAttr(\"redirect\"));\n  }\n\n  // If no path was provided, look up the path and then redirect there\n  try {\n    const { data } = await get(`/self`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n    if (data.tenant && data.tenant.loginRedirectPath) {\n      redirectToPath(data.tenant.loginRedirectPath);\n    }\n  } catch (err) {\n    removeAllCookies();\n  }\n}\n\n/**\n * If the access token is invalid, redirect the browser to the\n * provided path.\n */\nexport async function redirectIfLoggedOut({ redirect } = {}) {\n  // If the user is logged in, return without doing anything\n  const { isLoggedIn } = await getSession();\n  if (isLoggedIn) {\n    return;\n  }\n\n  // Remove all cookies\n  removeAllCookies();\n\n  // Redirect to a provided path (check options first, then url querystring)\n  if (redirect) {\n    return redirectToPath(redirect);\n  } else if (getQueryAttr(\"redirect\")) {\n    return redirectToPath(getQueryAttr(\"redirect\"));\n  }\n\n  // If no redirect path was provided, do not redirect\n  return;\n}\n\n/**\n * Redirect to path portion of a URL.\n */\nexport function redirectToPath(pathOrUrl) {\n  // Return if no pathOrUrl, or if SSR or mobile\n  if (\n    !pathOrUrl ||\n    typeof document !== \"object\" ||\n    typeof window !== \"object\"\n  ) {\n    return;\n  }\n  try {\n    document && window;\n  } catch (error) {\n    return;\n  }\n\n  // Perform hard redirect\n  const el = document.createElement(\"a\");\n  el.href = pathOrUrl;\n  let path = `${el.pathname}${el.hash}${el.search}`;\n  if (el.pathname !== window.location.pathname) {\n    window.location.assign(path);\n  }\n}\n","import { post, put } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { getQueryAttr, handleRedirect } from \"./url.js\";\nimport { throwFormattedError } from \"./utils.js\";\nimport { exchange } from \"./refresh.js\";\n\n/**\n * Register a new user with username, name, email, and password.\n * Redirect the browser after successful signup based on the redirectTo value returned.\n * @param {String} username\n * @param {String} name\n * @param {String} email\n * @param {String} password\n * @param {Object} userData - alias for the user.data object, since \"data\" is used in the response\n * @param {String} redirect - do not redirect if false, or redirect to a specific path\n */\nexport async function signupWithPassword({\n  username,\n  name,\n  email,\n  password,\n  userData,\n  redirect,\n} = {}) {\n  try {\n    const { data } = await post(`/auth/create`, {\n      tenantId: store.tenantId,\n      username,\n      name,\n      email,\n      password,\n      data: userData,\n    });\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    } else {\n      throw new Error(\"Please try again.\");\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Log a user in with email/username and password.\n * Redirect the browser after successful login based on the redirectTo value returned.\n * @param {Object} options\n */\nexport async function loginWithPassword({\n  email,\n  username,\n  emailOrUsername,\n  password,\n  redirect,\n}) {\n  try {\n    const { data } = await post(`/auth/basic`, {\n      tenantId: store.tenantId,\n      emailOrUsername: email || username || emailOrUsername,\n      password,\n    });\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorCode\")) {\n      return data;\n    }\n\n    throw new Error(\"Please try again.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Send a password reset link to the provided email.\n * @param {String} email\n */\nexport async function sendResetLink(email) {\n  try {\n    const { data } = await post(`/auth/reset/link`, {\n      email,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Set a user's password with their link credentials or JWT access token.\n *\n * If no method is provided, the order is:\n * - Check for link credentials; then\n * - Check for a JWT access token first\n *\n * @property {String} method (optional) \"link\" or \"jwt\"\n * @property {String} password\n * @property {String} existingPassword\n * @property {String} uuid\n * @property {String} token\n * @property {String} redirect\n * @returns\n */\nexport async function updatePassword({\n  method,\n  password,\n  existingPassword,\n  uuid,\n  token,\n  redirect,\n}) {\n  switch (method) {\n    // Allow for explicit setting of method\n    case \"link\":\n      return updatePasswordWithLink({ uuid, token, password, redirect });\n    case \"jwt\":\n      return updatePasswordWithJwt({ password, existingPassword });\n    default:\n      // Default (no method provided) is to look for link credentials first, then JWT access token\n      token = token || getQueryAttr(\"token\");\n      uuid = uuid || getQueryAttr(\"uuid\");\n      if (uuid && token) {\n        return updatePasswordWithLink({ uuid, token, password, redirect });\n      } else if (store.tokens.accessToken) {\n        return updatePasswordWithJwt({ password, existingPassword });\n      } else {\n        throw new Error(\n          \"updatePassword() was called without link credentials (token & uuid) or a JWT access token.\"\n        );\n      }\n  }\n}\n\nexport const resetPassword = updatePassword;\n\nexport async function updatePasswordWithLink({\n  uuid,\n  token,\n  password,\n  redirect,\n}) {\n  try {\n    token = token || getQueryAttr(\"token\");\n    uuid = uuid || getQueryAttr(\"uuid\");\n    if (!token || !uuid) throw new Error(\"Missing token or uuid\");\n    const { data } = await put(`/auth/reset`, {\n      tenantId: store.tenantId,\n      uuid,\n      token,\n      password,\n    });\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      handleRedirect({ redirect, data });\n      return data;\n    } else {\n      throw new Error(\n        \"There was a problem resetting your password. Please try again.\"\n      );\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\nexport async function updatePasswordWithJwt({ password, existingPassword }) {\n  try {\n    if (!store.tokens.accessToken) {\n      throw new Error(\n        `updatePassword({ method: \"jwt\" }) was called without a JWT access token.`\n      );\n    }\n\n    const { data } = await put(\n      `/auth/basic`,\n      {\n        tenantId: store.tenantId,\n        password,\n        existingPassword,\n      },\n      {\n        headers: {\n          Authorization: `Bearer ${store.tokens.accessToken}`,\n        },\n      }\n    );\n\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { store } from \"./store.js\";\nimport { getQueryAttr } from \"./url.js\";\n\nexport function getProviderLink({ provider, redirect }) {\n  if (!provider) throw new Error(\"Missing provider\");\n  if (!store.tenantId) throw new Error(\"Missing tenantId\");\n\n  let url = `${store.baseUrl}auth/${provider}/login?tenant_id=${store.tenantId}&origin=${window.location.origin}`;\n\n  let redirectTo = redirect || getQueryAttr(\"redirect\");\n  if (redirect === false) {\n    redirectTo = typeof document === \"object\" && document.location.pathname;\n  }\n  if (redirectTo) {\n    url += `&redirect=${encodeURIComponent(redirectTo)}`;\n  }\n\n  return url;\n}\n\n/**\n * Log in or register a user via SSO provider.\n * Redirect the browser after successful authentication and 302 redirect from server.\n * @param {String} provider Name of SSO provider\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport function signonWithSso({ provider, redirect }) {\n  if (!provider) throw new Error(\"Missing provider\");\n  const url = getProviderLink({ provider, redirect });\n  window.location.assign(url);\n}\n","import { post, put } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { getQueryAttr, handleRedirect } from \"./url.js\";\nimport { exchange } from \"./refresh.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Log a user in with a token/uuid combo passed into the function or\n * in the URL querystring. ?token=...&uuid=...\n * @param {String} token\n * @param {UUID} uuid\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function loginWithLink({ token, uuid, redirect } = {}) {\n  try {\n    token = token || getQueryAttr(\"token\");\n    uuid = uuid || getQueryAttr(\"uuid\");\n    if (!token || !uuid) return;\n\n    const { data } = await put(\"/auth/link\", {\n      token,\n      uuid,\n      tenantId: store.tenantId,\n    });\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorCode\")) {\n      return data;\n    }\n\n    throw new Error(\"Problem logging in.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Send a login link to the provided email.\n * @param {String} email\n */\nexport async function sendLoginLink(email) {\n  try {\n    const { data } = await post(`/auth/link`, {\n      email,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Create or update a user and send them a link to log in.\n * @param {Object} inputs\n */\nexport async function sendPasswordlessLink({\n  email,\n  name,\n  username,\n  userData,\n  options,\n}) {\n  try {\n    const { data } = await post(`/auth/link`, {\n      email,\n      name,\n      username,\n      data: userData,\n      options,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { post, put } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { handleRedirect } from \"./url.js\";\nimport { exchange } from \"./refresh.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Verify that proper identifier is available for the channel\n * @property {String} channel \"sms\" or \"email\"\n * @property {String} phoneNumber\n * @property {String} email\n */\nfunction enforceChannel({ channel, phoneNumber, email }) {\n  if (channel !== \"sms\" && channel !== \"email\") {\n    throw new Error(\"Invalid channel\");\n  }\n  if (channel === \"sms\" && !phoneNumber) {\n    throw new Error(`SMS verification code requires \"phoneNumber\"`);\n  } else if (channel === \"email\" && !email) {\n    throw new Error(`Email verification code requires \"email\"`);\n  }\n}\n\n/**\n * Send a verification code to the provided email address or phone number.\n * @property {String} channel \"sms\" (default) or \"email\"\n * @property {String} phoneNumber\n * @property {String} email\n * @property {String} name\n * @property {String} username\n * @property {Object} data\n */\nexport async function sendVerificationCode({\n  channel = \"sms\",\n  phoneNumber,\n  email,\n  name,\n  username,\n  data,\n}) {\n  try {\n    enforceChannel({\n      channel,\n      phoneNumber,\n      email,\n    });\n\n    const { data: res } = await post(`/auth/code`, {\n      channel,\n      email,\n      phoneNumber,\n      name,\n      username,\n      data,\n      tenantId: store.tenantId,\n    });\n    return res;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Log a user in with a token/uuid combo passed into the function or\n * in the URL querystring. ?token=...&uuid=...\n * @param {String} token\n * @param {UUID} uuid\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function loginWithVerificationCode({\n  channel,\n  verificationCode,\n  email,\n  phoneNumber,\n  redirect,\n} = {}) {\n  try {\n    enforceChannel({\n      channel,\n      phoneNumber,\n      email,\n    });\n\n    const { data } = await put(`/auth/code`, {\n      channel,\n      verificationCode,\n      email,\n      phoneNumber,\n      tenantId: store.tenantId,\n    });\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorCode\")) {\n      return data;\n    }\n\n    throw new Error(\"Problem logging in.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { get, post } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { handleRedirect } from \"./url.js\";\nimport { exchange } from \"./refresh.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Log a user in with a TOTP authenticator code or a TOTP backup code,\n * plus an identifier for the user (e.g. userId, userUuid, or email)\n *\n * @property {String} totpCode \"123456\"\n * @property {String} backupCode \"aaaaa-bbbbb\"\n * @property {Integer} userId\n * @property {String} userUuid\n * @property {String} emailOrUsername\n * @property {String} email\n * @property {String} username\n * @property {String} phoneNumber\n * @property {String|Boolean} redirect - do not redirect if false, or redirect to given path\n */\nexport async function loginWithTotp({\n  totpCode,\n  backupCode,\n  userId,\n  userUuid,\n  emailOrUsername,\n  email,\n  username,\n  phoneNumber,\n  redirect,\n} = {}) {\n  try {\n    if (!totpCode && !backupCode) return;\n\n    const { data } = await post(`/auth/totp`, {\n      totpCode,\n      backupCode,\n      userId,\n      userUuid,\n      emailOrUsername,\n      email,\n      username,\n      phoneNumber,\n      tenantId: store.tenantId,\n    });\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorCode\")) {\n      return data;\n    }\n\n    throw new Error(\"Problem logging in.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\nexport async function getTotp() {\n  try {\n    if (!store.tokens.accessToken) {\n      throw new Error(`getTotp() was called without a JWT access token.`);\n    }\n\n    const { data } = await get(`/auth/totp`, {\n      headers: {\n        Authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { get } from \"./api.js\";\nimport { getIframe, postMessageAsPromise } from \"./iframe.js\";\nimport { store } from \"./store.js\";\nimport { removeAllCookies } from \"./cookies.js\";\nimport { setTokensFromCookies } from \"./tokens.js\";\nimport { handleRedirect } from \"./url\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Log a user out and redirect to the logout path.\n */\nexport async function logout({ method, redirect } = {}) {\n  if (method === \"saml\") {\n    return completeSamlLogout();\n  }\n  if (!store.tokens.accessToken) {\n    return removeAllCookies();\n  }\n\n  try {\n    const { data } = await get(`/auth/logout`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n    removeAllCookies();\n    handleRedirect({ redirect, data });\n  } catch (err) {\n    removeAllCookies();\n  }\n}\n\nasync function completeSamlLogout() {\n  if (!store.tokens.accessToken) {\n    throw new Error(\"Please log in to authorize your logout request.\");\n  }\n\n  try {\n    const { data } = await get(`/auth/saml/idp/token`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n\n    window.location.assign(\n      `${store.baseUrl}auth/saml/idp/logout?tenant_id=${store.tenantId}&token=${data.token}&uuid=${store.user.userUuid}`\n    );\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n// TODO re-enable exchange method once new endpoints are stable [06/15/21]\n// --------------------------\n// const iframe = getIframe();\n// if (!iframe) return;\n// try {\n//   const { data } = await postMessageAsPromise({\n//     type: \"logout\",\n//     tenantId: store.tenantId,\n//   });\n//   removeAllCookies();\n//   setTokensFromCookies();\n//   handleRedirect({ redirect, data });\n// } catch (error) {\n//   removeAllCookies();\n//   redirectToPath(\"/\");\n// }\n","export const apiUrl = `https://api.userfront.com/v0/`;\n\nexport const privateIPRegex =\n  /((^127\\.)|(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.))\\d{1,3}\\.\\d{1,3}/g;\n","import { get } from \"./api.js\";\nimport { privateIPRegex } from \"./constants.js\";\nimport { store } from \"./store.js\";\n\n/**\n * Global mode object\n */\nexport const mode = {\n  value: \"live\",\n  reason: undefined,\n  setMode,\n};\n\nsetModeSync();\n\n/**\n * Determine whether a hostname is in test mode.\n * @param {String} hn\n */\nexport function isTestHostname(hn) {\n  try {\n    const hostname = hn || window.location.hostname;\n    return !!(hostname.match(/localhost/g) || hostname.match(privateIPRegex));\n  } catch (err) {\n    return true;\n  }\n}\n\nexport function isHttps() {\n  try {\n    return window.location.protocol === \"https:\";\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Define the mode of operation (live or test)\n */\nexport async function setMode() {\n  try {\n    const { data } = await get(`/tenants/${store.tenantId}/mode`);\n    mode.value = data.mode || \"test\";\n    mode.reason = getReason(mode.value);\n    store.mode = mode.value;\n  } catch (err) {\n    mode.value = \"test\";\n    store.mode = mode.value;\n  }\n}\n\n/**\n * Estimate the mode without making an API call\n */\nexport function setModeSync() {\n  const modeValue = isTestHostname() || !isHttps() ? \"test\" : \"live\";\n  mode.value = modeValue;\n  mode.reason = getReason(modeValue);\n  store.mode = modeValue;\n}\n\n/**\n * Set the reason for the mode\n * - http\n * - domain\n */\nfunction getReason(mode) {\n  try {\n    if (mode === \"live\") {\n      return \"domain\";\n    }\n    if (window.location.protocol === \"http:\") {\n      return \"http\";\n    } else if (window.location.protocol !== \"https:\") {\n      return \"protocol\";\n    } else {\n      return \"domain\";\n    }\n  } catch (error) {}\n}\n","/**\n * user methods are refactored into a separate file to avoid a circular dependency\n * between Userfront.refresh() [which requires setUser()]\n * and Userfront.user.update() [which requires refresh()].\n */\nimport { put } from \"./api.js\";\nimport { store } from \"./store.js\";\nimport { refresh } from \"./refresh.js\";\nimport { getTotp } from \"./totp.js\";\nimport { getJwtPayload } from \"./utils.js\";\nimport { updatePassword } from \"./password.js\";\n\n/**\n * Update the user record on Userfront\n * @param {Object} payload User properties to update e.g. { name: 'John Doe' }\n */\nexport async function update(payload) {\n  if (!payload || Object.keys(payload).length < 1) {\n    return console.warn(\"Missing user properties to update\");\n  }\n\n  // Make request to update the user\n  await put(`/self`, payload, {\n    headers: {\n      authorization: `Bearer ${store.tokens.accessToken}`,\n    },\n  });\n\n  // Refresh the access and ID tokens, and set the store.user object from the ID token\n  await refresh();\n\n  return store.user;\n}\n\n/**\n * Determine whether the access token has a given role\n * @param {String} roleName\n * @param {Object} options\n * @returns {Boolean}\n */\nexport function hasRole(roleName, { tenantId } = {}) {\n  try {\n    if (!store.tokens.accessToken || !store.tenantId) {\n      return false;\n    }\n    const { authorization } = getJwtPayload(store.tokens.accessToken);\n    if (!authorization) {\n      return false;\n    }\n    tenantId = tenantId || store.tenantId;\n    if (!authorization[tenantId] || !authorization[tenantId].roles) {\n      return false;\n    }\n    return authorization[tenantId].roles.indexOf(roleName) > -1;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Add the methods to the store.user object\n */\nstore.user.update = update;\nstore.user.hasRole = hasRole;\nstore.user.updatePassword = updatePassword;\nstore.user.getTotp = getTotp;\n","import axios from \"axios\";\nimport { store } from \"./store.js\";\nimport {\n  tokens,\n  accessToken,\n  idToken,\n  setTokensFromCookies,\n  setTokenNames,\n} from \"./tokens\";\nimport { getSession } from \"./session\";\nimport { redirectIfLoggedIn, redirectIfLoggedOut } from \"./url.js\";\nimport { signup } from \"./signup.js\";\nimport { login } from \"./login.js\";\nimport { updatePassword, resetPassword, sendResetLink } from \"./password.js\";\nimport { sendLoginLink } from \"./link.js\";\nimport { sendVerificationCode } from \"./verificationCode\";\nimport { logout } from \"./logout.js\";\nimport { mode, setMode, setModeSync } from \"./mode.js\";\n// import { setIframe } from \"./iframe.js\";\nimport { user } from \"./user.js\";\nimport \"./user.methods.js\";\nimport { refresh } from \"./refresh.js\";\nimport { apiUrl } from \"./constants.js\";\n\nlet initCallbacks = [];\n\n/**\n * Initialize the Userfront library.\n * @param {String} tenantId\n */\nfunction init(tenantId, opts = {}) {\n  if (!tenantId) return console.warn(\"Userfront initialized without tenantId\");\n\n  store.tenantId = tenantId;\n\n  store.baseUrl = opts.baseUrl || apiUrl;\n  if (!store.baseUrl.endsWith(\"/\")) {\n    store.baseUrl += \"/\";\n  }\n\n  if (opts.domain) {\n    store.domain = opts.domain;\n    const url = `https://${store.domain}`;\n    axios.defaults.headers.common[\"x-application-id\"] = url;\n    axios.defaults.headers.common[\"x-origin\"] = url;\n  }\n\n  setTokenNames();\n  // setIframe(); // TODO re-enable when iframe is needed\n  setTokensFromCookies();\n  setModeSync();\n\n  try {\n    if (initCallbacks.length > 0) {\n      initCallbacks.forEach((cb) => {\n        if (!cb || typeof cb !== \"function\") return;\n        cb({ tenantId });\n      });\n    }\n    initCallbacks = [];\n  } catch (error) {}\n}\n\n/**\n * Add a callback function to be called upon Userfront.init()\n * @param {Function} cb\n */\nfunction addInitCallback(cb) {\n  if (!cb || typeof cb !== \"function\") return;\n  initCallbacks.push(cb);\n}\n\n/**\n\n * Register a window-level event called \"urlchanged\" that will fire\n * whenever the browser URL changes.\n */\nlet isRegistered = false;\nfunction registerUrlChangedEventListener() {\n  if (isRegistered) return;\n  isRegistered = true;\n  try {\n    history.pushState = ((f) =>\n      function pushState() {\n        var ret = f.apply(this, arguments);\n        window.dispatchEvent(new Event(\"pushstate\"));\n        window.dispatchEvent(new Event(\"urlchanged\"));\n        return ret;\n      })(history.pushState);\n\n    history.replaceState = ((f) =>\n      function replaceState() {\n        var ret = f.apply(this, arguments);\n        window.dispatchEvent(new Event(\"replacestate\"));\n        window.dispatchEvent(new Event(\"urlchanged\"));\n        return ret;\n      })(history.replaceState);\n\n    window.addEventListener(\"popstate\", () => {\n      window.dispatchEvent(new Event(\"urlchanged\"));\n    });\n  } catch (error) {}\n}\n\n/**\n * EXPORTS\n */\n\nexport default {\n  // index\n  addInitCallback,\n  init,\n  registerUrlChangedEventListener,\n\n  //logout\n  logout,\n\n  // mode\n  mode,\n  setMode,\n\n  // refresh\n  refresh: (a, b, c) => {\n    try {\n      console.warn(\n        \"Userfront.refresh() is deprecated and will be removed. Please use Userfront.tokens.refresh() instead.\"\n      );\n    } catch (error) {}\n    return refresh(a, b, c);\n  },\n\n  // signon\n  login,\n  resetPassword,\n  updatePassword,\n  sendLoginLink,\n  sendResetLink,\n  sendVerificationCode,\n  signup,\n\n  // store\n  store,\n\n  // tokens\n  tokens,\n  accessToken,\n  idToken,\n\n  // session\n  getSession,\n\n  // url\n  redirectIfLoggedIn,\n  redirectIfLoggedOut,\n\n  // user\n  user,\n\n  // utils\n};\n","import { loginWithPassword } from \"./password.js\";\nimport { loginWithLink, sendPasswordlessLink } from \"./link.js\";\nimport { signonWithSso } from \"./sso.js\";\nimport { loginWithTotp } from \"./totp.js\";\nimport { loginWithVerificationCode } from \"./verificationCode.js\";\nimport { completeSamlLogin } from \"./saml.js\";\n\n/**\n * Log a user in via the provided method. This method serves to call other\n * methods, depending on the \"method\" parameter passed in.\n * @param {String} method\n * @param {Number} userId\n * @param {String} userUuid\n * @param {String} email\n * @param {String} username\n * @param {String} emailOrUsername\n * @param {String} phoneNumber\n * @param {String} password\n * @param {String} token\n * @param {String} uuid\n * @param {String} totpCode\n * @param {String} backupCode\n * @param {String} channel \"sms\" or \"email\"\n * @param {String} verificationCode\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function login({\n  method,\n  // User identifiers\n  userId,\n  userUuid,\n  email,\n  username,\n  emailOrUsername,\n  phoneNumber,\n  // Password\n  password,\n  // Link\n  token,\n  uuid,\n  // Totp\n  totpCode,\n  backupCode,\n  // Verification code\n  channel,\n  verificationCode,\n  // Other\n  redirect,\n} = {}) {\n  if (!method) {\n    throw new Error('Userfront.login called without \"method\" property.');\n  }\n  switch (method) {\n    case \"apple\":\n    case \"azure\":\n    case \"facebook\":\n    case \"github\":\n    case \"google\":\n    case \"linkedin\":\n      return signonWithSso({ provider: method, redirect });\n    case \"password\":\n      return loginWithPassword({\n        email,\n        username,\n        emailOrUsername,\n        password,\n        redirect,\n      });\n    case \"passwordless\":\n      return sendPasswordlessLink({ email });\n    case \"link\":\n      return loginWithLink({ token, uuid, redirect });\n    case \"totp\":\n      return loginWithTotp({\n        totpCode,\n        backupCode,\n        userId,\n        userUuid,\n        emailOrUsername,\n        email,\n        username,\n        phoneNumber,\n        redirect,\n      });\n    case \"verificationCode\":\n      return loginWithVerificationCode({\n        channel,\n        email,\n        phoneNumber,\n        verificationCode,\n        redirect,\n      });\n    case \"saml\":\n      return completeSamlLogin();\n    default:\n      throw new Error('Userfront.login called with invalid \"method\" property.');\n  }\n}\n","import { get } from \"./api.js\";\nimport { store } from \"./store.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\nexport async function completeSamlLogin() {\n  try {\n    if (!store.tokens.accessToken) {\n      return console.warn(\"Cannot complete SAML login without access token\");\n    }\n\n    const { data } = await get(`/auth/saml/idp/token`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n\n    window.location.assign(\n      `${store.baseUrl}auth/saml/idp/login?tenant_id=${store.tenantId}&token=${data.token}&uuid=${store.user.userUuid}`\n    );\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { signupWithPassword } from \"./password.js\";\nimport { signonWithSso } from \"./sso.js\";\nimport { sendPasswordlessLink } from \"./link.js\";\nimport { sendVerificationCode } from \"./verificationCode.js\";\n\n/**\n * Register a user via the provided method. This method serves to call other\n * methods, depending on the \"method\" parameter passed in.\n * @param {String} method\n * @param {String} email\n * @param {String} username\n * @param {String} phoneNumber\n * @param {String} name\n * @param {Object} data - Object for custom user fields\n * @param {String} password\n * @param {String} channel \"sms\" or \"email\"\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function signup({\n  method,\n  email,\n  username,\n  phoneNumber,\n  name,\n  data,\n  password,\n  channel,\n  redirect,\n} = {}) {\n  if (!method) {\n    throw new Error('Userfront.signup called without \"method\" property.');\n  }\n  switch (method) {\n    case \"apple\":\n    case \"azure\":\n    case \"facebook\":\n    case \"github\":\n    case \"google\":\n    case \"linkedin\":\n      return signonWithSso({ provider: method, redirect });\n    case \"password\":\n      return signupWithPassword({\n        username,\n        name,\n        email,\n        password,\n        userData: data,\n        redirect,\n      });\n    case \"passwordless\":\n      return sendPasswordlessLink({ email, name, username, userData: data });\n    case \"verificationCode\":\n      return sendVerificationCode({\n        channel,\n        email,\n        phoneNumber,\n        name,\n        username,\n        data,\n      });\n    default:\n      throw new Error(\n        'Userfront.signup called with invalid \"method\" property.'\n      );\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}